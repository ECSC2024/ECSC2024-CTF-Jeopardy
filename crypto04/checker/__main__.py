

# This file was *autogenerated* from the file __main__.sage
from sage.all_cmdline import *   # import sage library

_sage_const_16 = Integer(16); _sage_const_2 = Integer(2); _sage_const_15 = Integer(15); _sage_const_10 = Integer(10); _sage_const_128 = Integer(128); _sage_const_1337 = Integer(1337); _sage_const_8 = Integer(8); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_5000 = Integer(5000); _sage_const_100 = Integer(100)
import logging
logging.disable()
from pwn import remote, process

def xor(a,b):
    return bytes([x^y for x,y in zip(a,b)])

dim = _sage_const_16 
num_rand_pts = _sage_const_2 **_sage_const_15  + _sage_const_2 **_sage_const_10 
P = [os.urandom(dim) for _ in range(_sage_const_128 )]
C = [os.urandom(dim) for _ in range(_sage_const_128 )]
random_pts = [os.urandom(dim) for _ in range(num_rand_pts)]
query = ""
for el in P:
    for m in C:
        query += xor(el,m).hex()
for pt in random_pts:
    query += pt.hex()

HOST = os.environ.get("HOST", "localhost")
PORT = int(os.environ.get("PORT", _sage_const_1337 ))

chall = remote(HOST, PORT)
chall.recvuntil(b"> ")
chall.sendline(query.encode())
res = chall.recvline().strip().decode()
pt_chunks = []
ct_chunks = []
random_pts = []
random_cts = []
print("Done connection")
F = GF(_sage_const_2 )

for a in range(len(P)):
    tmp = []
    tmp2 = []
    for b in range(len(C)):
        tmp.append(vector(F, Integer(query[a*dim*_sage_const_2 *len(C)+b*dim*_sage_const_2 :][:dim*_sage_const_2 ],_sage_const_16 ).digits(base=_sage_const_2 , padto=_sage_const_8 *dim)))
        tmp2.append(vector(F, Integer(res[a*dim*_sage_const_2 *len(C)+b*dim*_sage_const_2 :][:dim*_sage_const_2 ],_sage_const_16 ).digits(base=_sage_const_2 , padto=_sage_const_8 *dim)))
    pt_chunks.append(tmp)
    ct_chunks.append(tmp2)

for i in range(num_rand_pts):
    random_pts.append(vector(F, Integer(query[len(P)*dim*_sage_const_2 *len(C) + i*dim*_sage_const_2 :][:dim*_sage_const_2 ],_sage_const_16 ).digits(base=_sage_const_2 , padto=_sage_const_8 *dim)))
    random_cts.append(vector(F, Integer(res[len(P)*dim*_sage_const_2 *len(C) + i*dim*_sage_const_2 :][:dim*_sage_const_2 ],_sage_const_16 ).digits(base=_sage_const_2 , padto=_sage_const_8 *dim)))

print("Starting inv mixing 2")
zero_8 = vector(GF(_sage_const_2 ), [_sage_const_0 ]*_sage_const_8 )
inv_mixing_2 = []
for i in range(len(P)):
    if len(inv_mixing_2) == dim:
        break
    for j in range(i+_sage_const_1 ,len(P)):
        try_ct = ct_chunks[i][_sage_const_0 ] + ct_chunks[j][_sage_const_0 ]
        if any(m2*try_ct == zero_8 for m2 in inv_mixing_2):
            continue
        M = []
        for k in range(len(C)):
            M.append(ct_chunks[i][k] + ct_chunks[j][k])
        M = Matrix(F, M)
        r = M.rank()
        if r == _sage_const_8 *(dim-_sage_const_1 ):
            m2 = matrix(M.right_kernel().basis())
            inv_mixing_2.append(m2)
            if len(inv_mixing_2) == dim:
                break

print("Starting inv mixing 1")
mixing_1 = []
for m2 in inv_mixing_2:
    base_sub = matrix(m2.right_kernel().basis())
    base_pt = None
    cur_ker_pts = []
    for pt, ct in zip(random_pts, random_cts):
        if base_sub.stack(ct).rank() == _sage_const_8 *(dim-_sage_const_1 ):
            if not base_pt:
                base_pt = pt
            else:
                cur_ker_pts.append(pt + base_pt)
    M = matrix(GF(_sage_const_2 ), cur_ker_pts)
    print(f"{ M.nrows() = }")
    m1 = matrix(M.right_kernel().basis())
    print(f"{m1.nrows() = }")
    mixing_1.append(m1)

mixing_1 = [Matrix(F, m1) for m1 in mixing_1]

pairs = _sage_const_5000 
tmp1 = []
tmp2 = []
for pt,ct in zip(random_pts[:pairs+_sage_const_100 ],random_cts[:pairs+_sage_const_100 ]):
    tmp1.append([m1 * pt for m1 in mixing_1])
    tmp2.append([m2 * ct for m2 in inv_mixing_2])


def retrieve_sbox():
    S = [{} for _ in range(dim)]
    for i in range(pairs):
        for pos in range(dim):
            S[pos][tuple(tmp1[i][pos])] = tmp2[i][pos]
    r = True
    for j in range(pairs, pairs+_sage_const_100 ):
        try:
            if all([S[pos][tuple(tmp1[j][pos])] == tmp2[j][pos] for pos in range(dim)]):
                pass
            else:
                r = False
                break
        except Exception as e:
            print([len(x) for x in S])
            r = False
            break
            pass
    if r:
        return S

recovered_sboxes = retrieve_sbox()

inv_sboxes = [{} for _ in range(dim)]

for i in range(dim):
    for k in recovered_sboxes[i]:
        inv_sboxes[i][tuple(recovered_sboxes[i][k])] = vector(F, k)

chall.recvline()

if recovered_sboxes is not None:
    inv_mixing_1 = mixing_1[_sage_const_0 ]
    for i in range(_sage_const_1 ,dim):
        inv_mixing_1 = inv_mixing_1.stack(mixing_1[i])
    inv_mixing_1 = inv_mixing_1.inverse()

    for _ in range(_sage_const_100 ):
        target = chall.recvline(False)
        target = vector(F, Integer(target,_sage_const_16 ).digits(base=_sage_const_2 , padto=_sage_const_8 *dim))
        target = [m2 * target for m2 in inv_mixing_2]
        target = [inv_sboxes[i][tuple(x)] for i,x in enumerate(target)]
        target = vector(F, sum([list(x) for x in target],[]))
        target = inv_mixing_1 * target
        res = hex(int(ZZ(list(target), base=_sage_const_2 )))[_sage_const_2 :-_sage_const_2 ].zfill(_sage_const_2 *dim-_sage_const_2 )
        chall.recvuntil(b"> ")
        chall.sendline(res.encode())
else:
    print("sploit failed :(")
    exit()

print(chall.recvline().decode())

