

# This file was *autogenerated* from the file __main__.sage
from sage.all_cmdline import *   # import sage library

_sage_const_239019556058548081539763731767358519973 = Integer(239019556058548081539763731767358519973); _sage_const_11 = Integer(11); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_133660577740454676305948404600566797994 = Integer(133660577740454676305948404600566797994); _sage_const_12 = Integer(12); _sage_const_8 = Integer(8); _sage_const_2 = Integer(2); _sage_const_50853858759521010453592688907791911225 = Integer(50853858759521010453592688907791911225); _sage_const_156893423039651253351316307339945502422 = Integer(156893423039651253351316307339945502422); _sage_const_100774561144590475569157120930767342387 = Integer(100774561144590475569157120930767342387); _sage_const_218728496724280042701446122970647661523 = Integer(218728496724280042701446122970647661523); _sage_const_115367896606755692925113233629944781384 = Integer(115367896606755692925113233629944781384); _sage_const_211093354487559124632805793736258741445 = Integer(211093354487559124632805793736258741445); _sage_const_6 = Integer(6); _sage_const_3 = Integer(3)#!/usr/bin/env sage
from random import SystemRandom
from hashlib import sha256
from json import loads, dumps
from pwn import remote, process
import os

LOCAL = False

if LOCAL:
    host, port = 'localhost', '47012'
else:
    host, port = os.getenv('HOST', 'smithing.challs.jeopardy.ecsc2024.it'), os.getenv('PORT', '47012')

def intify(x):
    return list(map(int, x))

def strify(x):
    return list(map(str, x))

class BN:
    def __init__(self):
        self.p      = _sage_const_239019556058548081539763731767358519973
        self.Fp     = GF(self.p)
        self.b      = _sage_const_11
        self.EFp    = EllipticCurve(self.Fp, [_sage_const_0 , self.b])
        self.O_EFp  = self.EFp([_sage_const_0 , _sage_const_1 , _sage_const_0 ])
        self.G1     = self.EFp((_sage_const_1 , _sage_const_133660577740454676305948404600566797994 ))
        self.t      = self.EFp.trace_of_frobenius()
        self.n      = self.EFp.order()
        self.k      = _sage_const_12
        self.bits   = ZZ(self.p).nbits()
        self.bytes  = ceil(self.bits/_sage_const_8 )

        Fp2 = GF(self.p**_sage_const_2 , names=('a',)); (a,) = Fp2._first_ngens(1)
        self.Fp2    = Fp2
        self.eps    = _sage_const_50853858759521010453592688907791911225 *a + _sage_const_156893423039651253351316307339945502422
        self.EFp2   = EllipticCurve(self.Fp2, [_sage_const_0 , self.b/self.eps])
        self.O_EFp2 = self.EFp2([_sage_const_0 , _sage_const_1 , _sage_const_0 ])
        self.G2     = self.EFp2((_sage_const_100774561144590475569157120930767342387 *a + _sage_const_218728496724280042701446122970647661523 , _sage_const_115367896606755692925113233629944781384 *a + _sage_const_211093354487559124632805793736258741445 ))
        self.h      = self.EFp2.order()//self.n

        Fp2u = self.Fp2['u']; (u,) = Fp2u._first_ngens(1)
        Fp12 = (u**_sage_const_6  - self.eps).root_field(names=('z',)); (z,) = Fp12._first_ngens(1)
        self.Fp2u   = Fp2u
        self.Fp12   = Fp12
        self.z      = z
        self.EFp12  = EllipticCurve(self.Fp12, [_sage_const_0 , self.b])

    def phi(self, P):
        assert P in self.EFp2 and P != self.O_EFp2 and self.n*P == self.O_EFp2, f'Point {P} not in <G2>'
        Px, Py = P.xy()
        return self.EFp12(self.z**_sage_const_2  * Px, self.z**_sage_const_3  * Py)

    def e(self, P, Q):
        assert P in self.EFp  and P != self.O_EFp, f'Point {P} not in <G1>'
        assert Q in self.EFp2 and Q != self.O_EFp2 and self.n*Q == self.O_EFp2, f'Point {Q} not in <G2>'
        return self.EFp12(P).ate_pairing(self.phi(Q), self.n, self.k, self.t, self.p)

class User:
    def __init__(self, params, sk, uid):
        self.curve = BN()
        self.r     = SystemRandom()
        self.p     = self.curve.n

        self.P_G1, self.Q = [self.curve.EFp(params[k]) for k in ['P_G1', 'Q']]
        self.P_G2         = self.curve.EFp2(params['P_G2'])

        self.sk  = tuple(map(self.curve.EFp2, sk))
        self.Qid = self.H0(uid)

    def rng(self):
        return self.r.randrange(self.p)

    def H(self, x):
        return int.from_bytes(sha256(x).digest()[:self.curve.bytes], 'big') % self.p

    def H0(self, uid):
        x0 = int.from_bytes(sha256(uid.encode()).digest(), 'big') % self.curve.p
        while 1:
            x0 += 1
            try:
                P = self.curve.h * self.curve.EFp2.lift_x(x0)
                if P != self.curve.O_EFp2 and self.p * P == self.curve.O_EFp2:
                    return P
            except:
                continue

    def sign(self, m):
        k = self.rng()
        R = k * self.P_G1
        S = int(pow(k, -_sage_const_1 , self.p)) * self.sk[_sage_const_0 ] + self.H(m.encode()) * self.sk[_sage_const_1 ]
        R, S = intify(R.xy()), strify(S.xy())
        return (R, S)

    def init_verification(self, role, sig, m, Qid_signer):
        self.role, self.verification_step = role.lower(), _sage_const_0
        self.x, self.y, self.y_inv = None, None, None
        self.sig = {'R': self.curve.EFp(sig[_sage_const_0 ]), 'S': self.curve.EFp2(sig[_sage_const_1 ]), 'm': m.encode(), 'Qid': Qid_signer}
        self.verifying = True
        return

    def verify(self, **kwargs):
        assert self.verifying

        if self.role == 'verifier':
            if self.verification_step == _sage_const_0 :
                self.x, self.y = [self.rng() for _ in range(_sage_const_2 )]
                self.y_inv = int(pow(self.y, -_sage_const_1 , self.p))
                C = self.x * self.y * self.sig['R']
                C = intify(C.xy())
                self.verification_step += _sage_const_1
                return C

            elif self.verification_step == _sage_const_1 :
                assert 't' in kwargs and 'r' in kwargs
                t, r = kwargs['t'], kwargs['r']
                t, r = list(map(self.curve.Fp12, [t, r]))

                lhs0 = self.curve.e(self.sig['R'], self.sig['S']) ** self.x
                rhs0 = self.curve.e(self.Q, self.sig['Qid']) ** self.x *                        r ** (self.H(self.sig['m']) * self.y_inv)

                lhs1 = r ** self.y_inv *                        t ** self.x     *                        self.curve.e(self.P_G1, self.sig['Qid']) ** self.x
                rhs1 = self.curve.e(self.sig['R'] + self.Q, self.P_G2) ** self.x

                self.verifying = False
                if lhs0 == rhs0 and lhs1 == rhs1:
                    return True
                return False

        elif self.role == 'signer':
            assert 'C' in kwargs
            C = self.curve.EFp(kwargs['C'])
            t = self.curve.e(self.sig['R'] + self.Q, self.P_G2 - self.sk[_sage_const_1 ])
            r = self.curve.e(C, self.sk[_sage_const_1 ])
            t, r = strify([t, r])
            self.verifying = False
            return t, r

with remote(host, port) as chall:
    chall.recvline()
    params = loads(chall.recvline(False).decode())
    print(f'[+] received params')

    uname = 'phi'
    chall.sendlineafter(b'username: ', uname.encode())
    chall.recvline()
    sk0 = loads(chall.recvline(False).decode())
    sk1 = loads(chall.recvline(False).decode())
    sk = (sk0, sk1)

    user = User(params, sk, uname)
    print(f'[+] registered')

    target = f'I, the eternal Admin, keeper of all secrets, hereby decree that you, {uname}, are worthy to glimpse my deepest and most ancient secret: the flag.'

    admin_Qid = user.H0('admin')
    R = user.Q
    S = admin_Qid + user.H(target.encode()) * user.P_G2

    sig = (intify(R.xy()), strify(S.xy()))
    chall.sendline(dumps(sig).encode())
    chall.sendline(target.encode())
    chall.sendline(b'admin')
    C = user.curve.EFp(loads(chall.recvline(False).decode().split('C = ')[-_sage_const_1 ]))
    print(f'[+] got {C = }')

    r = user.curve.e(C, user.P_G2)
    t = user.curve.e(R + user.Q, user.P_G2) * (user.curve.e(user.P_G1, admin_Qid) ** -_sage_const_1 ) * (user.curve.e(user.Q, user.P_G2) ** -_sage_const_1 )
    print(f'[+] crafted (t, r), sending..')

    tr = strify([t, r])
    chall.sendline(dumps(tr).encode())

    print(chall.recvline(False).decode().split()[-_sage_const_1 ])

